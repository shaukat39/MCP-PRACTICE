#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_node_util = require("util");
var readline2 = __toESM(require("readline/promises"));
var import_node_process3 = require("process");
var import_zod3 = require("zod");
var import_inference = require("@huggingface/inference");
var import_mcp_client = require("@huggingface/mcp-client");

// package.json
var version = "0.3.1";

// src/lib/types.ts
var import_zod = require("zod");
var ServerConfigSchema = import_zod.z.discriminatedUnion("type", [
  import_zod.z.object({
    type: import_zod.z.literal("stdio"),
    command: import_zod.z.string(),
    args: import_zod.z.array(import_zod.z.string()).optional(),
    env: import_zod.z.record(import_zod.z.string()).optional(),
    cwd: import_zod.z.string().optional()
  }),
  import_zod.z.object({
    type: import_zod.z.literal("http"),
    url: import_zod.z.union([import_zod.z.string(), import_zod.z.string().url()]),
    headers: import_zod.z.record(import_zod.z.string()).optional()
  }),
  import_zod.z.object({
    type: import_zod.z.literal("sse"),
    url: import_zod.z.union([import_zod.z.string(), import_zod.z.string().url()]),
    headers: import_zod.z.record(import_zod.z.string()).optional()
  })
]);
var InputConfigSchema = import_zod.z.object({
  id: import_zod.z.string(),
  description: import_zod.z.string(),
  type: import_zod.z.string().optional(),
  password: import_zod.z.boolean().optional()
});

// src/lib/utils.ts
var import_util = require("util");
function debug(...args) {
  if (process.env.DEBUG) {
    console.debug((0, import_util.inspect)(args, { depth: Infinity, colors: true }));
  }
}
function error(...args) {
  console.error(ANSI.RED + args.join("") + ANSI.RESET);
}
var ANSI = {
  BLUE: "\x1B[34m",
  GRAY: "\x1B[90m",
  GREEN: "\x1B[32m",
  RED: "\x1B[31m",
  RESET: "\x1B[0m",
  YELLOW: "\x1B[33m"
};

// src/lib/mainCliLoop.ts
var readline = __toESM(require("readline/promises"));
var import_node_process = require("process");
async function mainCliLoop(agent) {
  const rl = readline.createInterface({ input: import_node_process.stdin, output: import_node_process.stdout });
  let abortController = new AbortController();
  let waitingForInput = false;
  async function waitForInput() {
    waitingForInput = true;
    const input = await rl.question("> ");
    waitingForInput = false;
    return input;
  }
  rl.on("SIGINT", async () => {
    if (waitingForInput) {
      await agent.cleanup();
      import_node_process.stdout.write("\n");
      rl.close();
    } else {
      abortController.abort();
      abortController = new AbortController();
      import_node_process.stdout.write("\n");
      import_node_process.stdout.write(ANSI.GRAY);
      import_node_process.stdout.write("Ctrl+C a second time to exit");
      import_node_process.stdout.write(ANSI.RESET);
      import_node_process.stdout.write("\n");
    }
  });
  process.on("uncaughtException", (err) => {
    import_node_process.stdout.write("\n");
    rl.close();
    throw err;
  });
  import_node_process.stdout.write(ANSI.BLUE);
  import_node_process.stdout.write(`Agent loaded with ${agent.availableTools.length} tools:
`);
  import_node_process.stdout.write(agent.availableTools.map((t) => `- ${t.function.name}`).join("\n"));
  import_node_process.stdout.write(ANSI.RESET);
  import_node_process.stdout.write("\n");
  while (true) {
    const input = await waitForInput();
    for await (const chunk of agent.run(input, { abortSignal: abortController.signal })) {
      if ("choices" in chunk) {
        const delta = chunk.choices[0]?.delta;
        if (delta.content) {
          import_node_process.stdout.write(delta.content);
        }
        if (delta.tool_calls) {
          import_node_process.stdout.write(ANSI.GRAY);
          for (const deltaToolCall of delta.tool_calls) {
            if (deltaToolCall.id) {
              import_node_process.stdout.write(`<Tool ${deltaToolCall.id}>
`);
            }
            if (deltaToolCall.function.name) {
              import_node_process.stdout.write(deltaToolCall.function.name + " ");
            }
            if (deltaToolCall.function.arguments) {
              import_node_process.stdout.write(deltaToolCall.function.arguments);
            }
          }
          import_node_process.stdout.write(ANSI.RESET);
        }
      } else {
        import_node_process.stdout.write("\n\n");
        import_node_process.stdout.write(ANSI.GREEN);
        import_node_process.stdout.write(`Tool[${chunk.name}] ${chunk.tool_call_id}
`);
        import_node_process.stdout.write(chunk.content);
        import_node_process.stdout.write(ANSI.RESET);
        import_node_process.stdout.write("\n\n");
      }
    }
    import_node_process.stdout.write("\n");
  }
}

// src/lib/webServer.ts
var import_node_http = require("http");
var import_zod2 = require("zod");
var import_node_process2 = require("process");
var REQUEST_ID_HEADER = "X-Request-Id";
var ChatCompletionInputSchema = import_zod2.z.object({
  messages: import_zod2.z.array(
    import_zod2.z.object({
      role: import_zod2.z.enum(["user", "assistant"]),
      content: import_zod2.z.string().or(
        import_zod2.z.array(
          import_zod2.z.object({
            type: import_zod2.z.literal("text"),
            text: import_zod2.z.string()
          }).or(
            import_zod2.z.object({
              type: import_zod2.z.literal("image_url"),
              image_url: import_zod2.z.object({
                url: import_zod2.z.string()
              })
            })
          )
        )
      )
    })
  ),
  /// Only allow stream: true
  stream: import_zod2.z.literal(true)
});
function getJsonBody(req) {
  return new Promise((resolve, reject) => {
    let data = "";
    req.on("data", (chunk) => data += chunk);
    req.on("end", () => {
      try {
        resolve(JSON.parse(data));
      } catch (e) {
        reject(e);
      }
    });
    req.on("error", reject);
  });
}
var ServerResp = class extends import_node_http.ServerResponse {
  error(statusCode, reason) {
    this.writeHead(statusCode).end(JSON.stringify({ error: reason }));
  }
};
function startServer(agent) {
  const server = (0, import_node_http.createServer)({ ServerResponse: ServerResp }, async (req, res) => {
    res.setHeader(REQUEST_ID_HEADER, crypto.randomUUID());
    res.setHeader("Content-Type", "application/json");
    if (req.method === "POST" && req.url === "/v1/chat/completions") {
      let body;
      let requestBody;
      try {
        body = await getJsonBody(req);
      } catch {
        return res.error(400, "Invalid JSON");
      }
      try {
        requestBody = ChatCompletionInputSchema.parse(body);
      } catch (err) {
        if (err instanceof import_zod2.z.ZodError) {
          return res.error(400, "Invalid ChatCompletionInput body \n" + JSON.stringify(err));
        }
        return res.error(400, "Invalid ChatCompletionInput body");
      }
      res.setHeaders(
        new Headers({
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        })
      );
      const messages = [
        {
          role: "system",
          content: agent.prompt
        },
        ...requestBody.messages
      ];
      for await (const chunk of agent.run(messages)) {
        if ("choices" in chunk) {
          res.write(`data: ${JSON.stringify(chunk)}

`);
        } else {
          const chunkToolcallInfo = {
            choices: [
              {
                index: 0,
                delta: {
                  role: "tool",
                  content: `Tool[${chunk.name}] ${chunk.tool_call_id}
` + chunk.content
                }
              }
            ],
            created: Math.floor(Date.now() / 1e3),
            id: chunk.tool_call_id,
            model: "",
            system_fingerprint: ""
          };
          res.write(`data: ${JSON.stringify(chunkToolcallInfo)}

`);
        }
      }
      res.end();
    } else {
      res.error(404, "Route or method not found, try POST /v1/chat/completions");
    }
  });
  server.listen(process.env.PORT ? parseInt(process.env.PORT) : 9999, () => {
    import_node_process2.stdout.write(ANSI.BLUE);
    import_node_process2.stdout.write(`Agent loaded with ${agent.availableTools.length} tools:
`);
    import_node_process2.stdout.write(agent.availableTools.map((t) => `- ${t.function.name}`).join("\n"));
    import_node_process2.stdout.write(ANSI.RESET);
    import_node_process2.stdout.write("\n");
    console.log(ANSI.GRAY + `listening on http://localhost:${server.address().port}` + ANSI.RESET);
  });
}

// src/lib/loadConfigFrom.ts
var import_node_path = require("path");
var import_promises = require("fs/promises");
var import_hub = require("@huggingface/hub");
var FILENAME_CONFIG = "agent.json";
var FILENAME_PROMPT = "PROMPT.md";
var TINY_AGENTS_HUB_REPO = {
  name: "tiny-agents/tiny-agents",
  type: "dataset"
};
async function tryLoadFromFile(filePath) {
  try {
    const configJson = await (0, import_promises.readFile)(filePath, { encoding: "utf8" });
    return { configJson };
  } catch {
    return void 0;
  }
}
async function tryLoadFromDirectory(dirPath) {
  const stats = await (0, import_promises.lstat)(dirPath).catch(() => void 0);
  if (!stats?.isDirectory()) {
    return void 0;
  }
  let prompt;
  try {
    prompt = await (0, import_promises.readFile)((0, import_node_path.join)(dirPath, FILENAME_PROMPT), { encoding: "utf8" });
  } catch {
    debug(`PROMPT.md not found in ${dirPath}, continuing without prompt template`);
  }
  try {
    return {
      configJson: await (0, import_promises.readFile)((0, import_node_path.join)(dirPath, FILENAME_CONFIG), { encoding: "utf8" }),
      prompt
    };
  } catch {
    error(`Config file not found in specified local directory.`);
    process.exit(1);
  }
}
async function tryLoadFromHub(agentId) {
  let configJson;
  try {
    const configPath = await (0, import_hub.downloadFileToCacheDir)({
      repo: TINY_AGENTS_HUB_REPO,
      path: `${agentId}/${FILENAME_CONFIG}`,
      accessToken: process.env.HF_TOKEN
    });
    configJson = await (0, import_promises.readFile)(configPath, { encoding: "utf8" });
  } catch {
    return void 0;
  }
  let prompt;
  try {
    const promptPath = await (0, import_hub.downloadFileToCacheDir)({
      repo: TINY_AGENTS_HUB_REPO,
      path: `${agentId}/${FILENAME_PROMPT}`,
      accessToken: process.env.HF_TOKEN
    });
    prompt = await (0, import_promises.readFile)(promptPath, { encoding: "utf8" });
  } catch {
    debug(
      `PROMPT.md not found in https://huggingface.co/datasets/tiny-agents/tiny-agents/tree/main/${agentId}, continuing without prompt template`
    );
  }
  return {
    configJson,
    prompt
  };
}
async function loadConfigFrom(loadFrom) {
  const fileConfig = await tryLoadFromFile(loadFrom);
  if (fileConfig) {
    return fileConfig;
  }
  const dirConfig = await tryLoadFromDirectory(loadFrom);
  if (dirConfig) {
    return dirConfig;
  }
  const repoConfig = await tryLoadFromHub(loadFrom);
  if (repoConfig) {
    return repoConfig;
  }
  error(
    `Config file not found in tiny-agents! Please make sure it exists locally or in https://huggingface.co/datasets/tiny-agents/tiny-agents.`
  );
  process.exit(1);
}

// src/cli.ts
var USAGE_HELP = `
Usage:
  tiny-agents [flags]
  tiny-agents run   "agent/id"
  tiny-agents serve "agent/id"

Available Commands:
  run         Run the Agent in command-line
  serve       Run the Agent as an OpenAI-compatible HTTP server

Flags:
  -h, --help      help for tiny-agents
  -v, --version   Show version information
`.trim();
var CLI_COMMANDS = ["run", "serve"];
function isValidCommand(command) {
  return CLI_COMMANDS.includes(command);
}
async function main() {
  const {
    values: { help, version: version2 },
    positionals
  } = (0, import_node_util.parseArgs)({
    options: {
      help: {
        type: "boolean",
        short: "h"
      },
      version: {
        type: "boolean",
        short: "v"
      }
    },
    allowPositionals: true
  });
  if (version2) {
    console.log(version);
    process.exit(0);
  }
  const command = positionals[0];
  const loadFrom = positionals[1];
  if (help) {
    console.log(USAGE_HELP);
    process.exit(0);
  }
  if (positionals.length !== 2 || !isValidCommand(command)) {
    error(`You need to call run or serve, followed by an agent id (local path or Hub identifier).`);
    console.log(USAGE_HELP);
    process.exit(1);
  }
  const { configJson, prompt } = await loadConfigFrom(loadFrom);
  const ConfigSchema = import_zod3.z.object({
    model: import_zod3.z.string(),
    provider: import_zod3.z.enum(import_inference.PROVIDERS_OR_POLICIES).optional(),
    endpointUrl: import_zod3.z.string().optional(),
    apiKey: import_zod3.z.string().optional(),
    inputs: import_zod3.z.array(InputConfigSchema).optional(),
    servers: import_zod3.z.array(ServerConfigSchema)
  }).refine((data) => data.provider !== void 0 || data.endpointUrl !== void 0, {
    message: "At least one of 'provider' or 'endpointUrl' is required"
  });
  let config;
  try {
    const parsedConfig = JSON.parse(configJson);
    config = ConfigSchema.parse(parsedConfig);
  } catch (err) {
    error("Invalid configuration file:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
  if (config.inputs && config.inputs.length > 0) {
    const rl = readline2.createInterface({ input: import_node_process3.stdin, output: import_node_process3.stdout });
    import_node_process3.stdout.write(ANSI.BLUE);
    import_node_process3.stdout.write("Some initial inputs are required by the agent. ");
    import_node_process3.stdout.write("Please provide a value or leave empty to load from env.");
    import_node_process3.stdout.write(ANSI.RESET);
    import_node_process3.stdout.write("\n");
    for (const inputItem of config.inputs) {
      const inputId = inputItem.id;
      const description = inputItem.description;
      const envSpecialValue = `\${input:${inputId}}`;
      const inputVars = /* @__PURE__ */ new Set();
      for (const server of config.servers) {
        if (server.type === "stdio" && server.env) {
          for (const [key, value] of Object.entries(server.env)) {
            if (value === envSpecialValue) {
              inputVars.add(key);
            }
          }
        }
        if ((server.type === "http" || server.type === "sse") && server.headers) {
          for (const [key, value] of Object.entries(server.headers)) {
            if (value.includes(envSpecialValue)) {
              inputVars.add(key);
            }
          }
        }
      }
      if (inputVars.size === 0) {
        import_node_process3.stdout.write(ANSI.YELLOW);
        import_node_process3.stdout.write(`Input ${inputId} defined in config but not used by any server.`);
        import_node_process3.stdout.write(ANSI.RESET);
        import_node_process3.stdout.write("\n");
        continue;
      }
      const envVariableKey = inputId.replaceAll("-", "_").toUpperCase();
      import_node_process3.stdout.write(ANSI.BLUE);
      import_node_process3.stdout.write(` \u2022 ${inputId}`);
      import_node_process3.stdout.write(ANSI.RESET);
      import_node_process3.stdout.write(`: ${description}. (default: load from ${envVariableKey}) `);
      import_node_process3.stdout.write("\n");
      const userInput = (await rl.question("")).trim();
      for (const server of config.servers) {
        if (server.type === "stdio" && server.env) {
          for (const [key, value] of Object.entries(server.env)) {
            if (value === envSpecialValue) {
              if (userInput) {
                server.env[key] = userInput;
              } else {
                const valueFromEnv = process.env[envVariableKey] || "";
                server.env[key] = valueFromEnv;
                if (valueFromEnv) {
                  import_node_process3.stdout.write(ANSI.GREEN);
                  import_node_process3.stdout.write(`Value successfully loaded from '${envVariableKey}'`);
                  import_node_process3.stdout.write(ANSI.RESET);
                  import_node_process3.stdout.write("\n");
                } else {
                  import_node_process3.stdout.write(ANSI.YELLOW);
                  import_node_process3.stdout.write(`No value found for '${envVariableKey}' in environment variables. Continuing.`);
                  import_node_process3.stdout.write(ANSI.RESET);
                  import_node_process3.stdout.write("\n");
                }
              }
            }
          }
        }
        if ((server.type === "http" || server.type === "sse") && server.headers) {
          for (const [key, value] of Object.entries(server.headers)) {
            if (value.includes(envSpecialValue)) {
              if (userInput) {
                server.headers[key] = value.replace(envSpecialValue, userInput);
              } else {
                const valueFromEnv = process.env[envVariableKey] || "";
                server.headers[key] = value.replace(envSpecialValue, valueFromEnv);
                if (valueFromEnv) {
                  import_node_process3.stdout.write(ANSI.GREEN);
                  import_node_process3.stdout.write(`Value successfully loaded from '${envVariableKey}'`);
                  import_node_process3.stdout.write(ANSI.RESET);
                  import_node_process3.stdout.write("\n");
                } else {
                  import_node_process3.stdout.write(ANSI.YELLOW);
                  import_node_process3.stdout.write(`No value found for '${envVariableKey}' in environment variables. Continuing.`);
                  import_node_process3.stdout.write(ANSI.RESET);
                  import_node_process3.stdout.write("\n");
                }
              }
            }
          }
        }
      }
    }
    import_node_process3.stdout.write("\n");
    rl.close();
  }
  const formattedServers = config.servers.map((server) => {
    switch (server.type) {
      case "stdio":
        return {
          type: "stdio",
          config: {
            command: server.command,
            args: server.args ?? [],
            env: server.env ?? {},
            cwd: server.cwd ?? process.cwd()
          }
        };
      case "http":
      case "sse":
        return {
          type: server.type,
          config: {
            url: server.url,
            requestInit: {
              headers: server.headers
            }
          }
        };
    }
  });
  const agent = new import_mcp_client.Agent(
    config.endpointUrl ? {
      endpointUrl: config.endpointUrl,
      model: config.model,
      apiKey: config.apiKey ?? process.env.API_KEY ?? process.env.HF_TOKEN,
      servers: formattedServers,
      prompt
    } : {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      provider: config.provider,
      model: config.model,
      apiKey: config.apiKey ?? process.env.API_KEY ?? process.env.HF_TOKEN,
      servers: formattedServers,
      prompt
    }
  );
  debug(agent);
  await agent.loadTools();
  if (command === "run") {
    mainCliLoop(agent);
  } else {
    startServer(agent);
  }
}
main();
